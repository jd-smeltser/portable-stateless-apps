<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0a0a">
  <title>Tasks</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --surface: #141414;
      --border: #262626;
      --border-light: #333;
      --text: #e5e5e5;
      --text-muted: #737373;
      --accent: #3b82f6;
      --success: #22c55e;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    #app {
      display: flex;
      height: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .new-btn {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 1.25rem;
      cursor: pointer;
    }

    .new-btn:hover { background: var(--border); }

    .tasks-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .section-label {
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      padding: 12px 12px 6px;
      margin-top: 8px;
    }

    .section-label:first-child { margin-top: 0; }
    .template-item { border-left: 2px solid var(--accent); }

    .task-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 4px;
      transition: all 0.15s;
    }

    .task-item:hover { background: var(--surface); }
    .task-item.active { background: var(--surface); border: 1px solid var(--border); }
    .task-item.completed { opacity: 0.5; }

    .task-checkbox {
      width: 20px;
      height: 20px;
      border: 2px solid var(--border-light);
      border-radius: 50%;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      margin-top: 2px;
    }

    .task-checkbox:hover { border-color: var(--success); }

    .task-item.completed .task-checkbox {
      background: var(--success);
      border-color: var(--success);
    }

    .task-item.completed .task-checkbox::after {
      content: '‚úì';
      color: white;
      font-size: 0.65rem;
      font-weight: 600;
    }

    .task-item-content { flex: 1; min-width: 0; }

    .task-item-title {
      font-size: 0.9rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .task-item.completed .task-item-title {
      text-decoration: line-through;
      color: var(--text-muted);
    }

    .task-item-preview {
      font-size: 0.75rem;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    .task-item-delete {
      opacity: 0;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      font-size: 1rem;
    }

    .task-item:hover .task-item-delete { opacity: 1; }
    .task-item-delete:hover { color: #ef4444; }

    /* Editor */
    .editor {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px 24px;
      padding-top: calc(env(safe-area-inset-top) + 16px);
      min-width: 0;
    }

    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      flex-shrink: 0;
    }

    .btn {
      padding: 8px 14px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 0.8rem;
      cursor: pointer;
    }

    .btn:hover { background: var(--border); }
    .btn.primary { background: var(--accent); border-color: var(--accent); color: white; }
    .btn.success { background: var(--success); border-color: var(--success); color: white; }

    .complete-btn {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .complete-btn.done {
      background: transparent;
      border-color: var(--success);
      color: var(--success);
    }

    #title {
      width: 100%;
      padding: 8px 0;
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 1.75rem;
      font-weight: 600;
      font-family: inherit;
      outline: none;
    }

    #title::placeholder { color: var(--text-muted); }

    #body {
      flex: 1;
      width: 100%;
      padding: 12px 0;
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 1rem;
      font-family: inherit;
      line-height: 1.75;
      resize: none;
      outline: none;
    }

    #body::placeholder { color: var(--text-muted); }

    /* Links panel */
    .links-panel {
      border-top: 1px solid var(--border);
      padding-top: 16px;
      margin-top: 16px;
    }

    .links-panel.empty { display: none; }

    .links-label {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 8px;
    }

    .links-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .link-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.8rem;
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s;
    }

    .link-chip:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .backlinks { margin-top: 12px; }

    /* Hint */
    .hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 8px;
      opacity: 0.7;
    }

    /* Status toast */
    .status {
      position: fixed;
      bottom: calc(env(safe-area-inset-bottom) + 16px);
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 100px;
      font-size: 0.8rem;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 500;
    }

    .status.visible { opacity: 1; }

    /* Mobile */
    @media (max-width: 700px) {
      .sidebar {
        position: fixed;
        left: 0; top: 0; bottom: 0;
        width: 300px;
        background: var(--bg);
        z-index: 100;
        transform: translateX(-100%);
        transition: transform 0.2s;
      }
      .sidebar.open { transform: translateX(0); }
      .sidebar-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.5);
        z-index: 99;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s;
      }
      .sidebar-backdrop.visible { opacity: 1; visibility: visible; }
      .editor { padding: 16px; }
      .mobile-menu-btn { display: flex; }
    }

    @media (min-width: 701px) {
      .mobile-menu-btn, .sidebar-backdrop { display: none; }
    }

    .mobile-menu-btn {
      width: 36px;
      height: 36px;
      display: none;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 1.1rem;
      cursor: pointer;
    }

    .empty-state {
      padding: 24px 16px;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.875rem;
    }

    .empty-editor {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="sidebar-backdrop" id="backdrop"></div>

    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <span class="logo">Tasks</span>
        <button class="new-btn" id="new-btn" title="New task">+</button>
      </div>
      <div class="tasks-list" id="tasks-list"></div>
    </aside>

    <main class="editor" id="editor">
      <div class="editor-header">
        <button class="btn mobile-menu-btn" id="menu-btn">‚ò∞</button>
        <div style="flex:1"></div>
        <button class="btn complete-btn" id="complete-btn">
          <span>‚úì</span> Mark Complete
        </button>
        <button class="btn" id="template-btn">Save as Template</button>
        <button class="btn" id="share-btn">Share</button>
        <button class="btn primary" id="copy-btn">Copy Link</button>
      </div>

      <input type="text" id="title" placeholder="Task title" autocomplete="off" spellcheck="true">
      <textarea id="body" placeholder="Add notes, details, or use @ to link..."></textarea>
      <div class="hint">Type @ to link to notes, other tasks, or projects</div>

      <!-- Links panel -->
      <div class="links-panel empty" id="links-panel">
        <div id="outgoing-links">
          <div class="links-label">LINKS TO</div>
          <div class="links-list" id="outgoing-list"></div>
        </div>
        <div class="backlinks" id="incoming-links">
          <div class="links-label">LINKED FROM</div>
          <div class="links-list" id="incoming-list"></div>
        </div>
      </div>
    </main>

    <div class="status" id="status"></div>
  </div>

  <script src="https://unpkg.com/lz-string@1.5.0/libs/lz-string.min.js"></script>
  <script type="module">
    import Registry from '../../core/registry.js';
    import Linker from '../../core/linker.js';
    import Omnibar from '../../core/omnibar.js';

    // ============================================
    // State
    // ============================================

    let currentRecordId = null;

    // ============================================
    // Elements
    // ============================================

    const titleEl = document.getElementById('title');
    const bodyEl = document.getElementById('body');
    const statusEl = document.getElementById('status');
    const tasksListEl = document.getElementById('tasks-list');
    const sidebarEl = document.getElementById('sidebar');
    const backdropEl = document.getElementById('backdrop');
    const linksPanel = document.getElementById('links-panel');
    const outgoingList = document.getElementById('outgoing-list');
    const incomingList = document.getElementById('incoming-list');
    const outgoingSection = document.getElementById('outgoing-links');
    const incomingSection = document.getElementById('incoming-links');
    const completeBtn = document.getElementById('complete-btn');

    // ============================================
    // URL Encoding
    // ============================================

    function encodeState(state) {
      return LZString.compressToEncodedURIComponent(JSON.stringify(state));
    }

    function decodeState(hash) {
      try {
        return JSON.parse(LZString.decompressFromEncodedURIComponent(hash));
      } catch (e) {
        return null;
      }
    }

    function getStateFromURL(url) {
      const hash = url.split('#')[1];
      return hash ? decodeState(hash) : null;
    }

    function getCurrentURL() {
      const record = Registry.get(currentRecordId);
      const currentDone = record?.meta?.done || false;
      const ts = record?.meta?.ts || Date.now();

      const state = { t: titleEl.value, b: bodyEl.value, done: currentDone, ts };
      // Always include hash with timestamp, even for empty tasks
      return window.location.pathname + '#' + encodeState(state);
    }

    // ============================================
    // Task Operations
    // ============================================

    function createTask(title = '') {
      const ts = Date.now();
      const state = { t: title, b: '', done: false, ts };
      const url = window.location.pathname + '#' + encodeState(state);
      const record = Registry.add('task', url, { meta: { title: title || 'Untitled', done: false, ts } });
      currentRecordId = record.id;
      titleEl.value = title;
      bodyEl.value = '';
      history.replaceState(null, '', url);
      renderTasksList();
      renderLinks();
      updateCompleteButton(false);
      titleEl.focus();
      closeSidebar();
      updateLinkerContext();
    }

    function selectTask(id) {
      const record = Registry.get(id);
      if (!record) return;

      currentRecordId = id;
      const state = getStateFromURL(record.url);
      titleEl.value = state?.t || '';
      bodyEl.value = state?.b || '';

      const hash = record.url.split('#')[1];
      history.replaceState(null, '', hash ? window.location.pathname + '#' + hash : window.location.pathname);

      renderTasksList();
      renderLinks();
      updateCompleteButton(state?.done || record.meta?.done || false);
      closeSidebar();
      updateLinkerContext();
    }

    function deleteTask(id, e) {
      e.stopPropagation();
      Registry.remove(id);
      const tasks = Registry.byType('task');
      if (currentRecordId === id) {
        tasks.length > 0 ? selectTask(tasks[0].id) : createTask();
      } else {
        renderTasksList();
      }
    }

    function updateCurrentTask() {
      if (!currentRecordId) return;

      const url = getCurrentURL();
      const title = titleEl.value || 'Untitled';
      const record = Registry.get(currentRecordId);
      const done = record?.meta?.done || false;
      const ts = record?.meta?.ts || Date.now();

      // Extract links from body text
      const linkIds = Linker.extractLinkIds(bodyEl.value);

      Registry.update(currentRecordId, {
        url,
        links: linkIds,
        meta: { title, preview: bodyEl.value.slice(0, 100), done, ts }
      });

      history.replaceState(null, '', url);
      renderTasksList();
      renderLinks();
    }

    function toggleComplete() {
      if (!currentRecordId) return;

      const record = Registry.get(currentRecordId);
      if (!record) return;

      const newDone = !record.meta?.done;
      const ts = record.meta?.ts || Date.now();

      // Update the URL with new done state
      const newState = {
        t: titleEl.value,
        b: bodyEl.value,
        done: newDone,
        ts
      };

      const url = window.location.pathname + '#' + encodeState(newState);

      Registry.update(currentRecordId, {
        url,
        meta: { ...record.meta, done: newDone, ts }
      });

      history.replaceState(null, '', url);
      renderTasksList();
      updateCompleteButton(newDone);
      showStatus(newDone ? 'Task completed!' : 'Task reopened');
    }

    function updateCompleteButton(done) {
      if (done) {
        completeBtn.innerHTML = '<span>‚Ü©</span> Reopen';
        completeBtn.classList.add('done');
      } else {
        completeBtn.innerHTML = '<span>‚úì</span> Complete';
        completeBtn.classList.remove('done');
      }
    }

    // ============================================
    // Templates
    // ============================================

    function saveAsTemplate() {
      const url = getCurrentURL();
      const record = Registry.get(currentRecordId);
      const ts = record?.meta?.ts || Date.now();
      // Templates store sourceApp to know where to create new records
      Registry.add('template', url, {
        meta: { title: titleEl.value || 'Untitled Template', ts, sourceApp: 'task' }
      });
      renderTasksList();
      showStatus('Template saved!');
    }

    function useTemplate(id) {
      const template = Registry.get(id);
      if (!template) return;

      // Get template content but create new timestamp for the new task
      const templateState = getStateFromURL(template.url);
      const ts = Date.now();
      const newState = {
        t: templateState?.t || '',
        b: templateState?.b || '',
        done: false,  // New tasks from templates start incomplete
        ts
      };
      const url = window.location.pathname + '#' + encodeState(newState);

      const record = Registry.add('task', url, {
        meta: { title: templateState?.t || 'Untitled', done: false, ts }
      });
      currentRecordId = record.id;

      titleEl.value = newState.t;
      bodyEl.value = newState.b;

      history.replaceState(null, '', url);

      renderTasksList();
      renderLinks();
      updateCompleteButton(false);
      titleEl.focus();
      closeSidebar();
      updateLinkerContext();
      showStatus('New task from template');
    }

    function deleteTemplate(id, e) {
      e.stopPropagation();
      Registry.remove(id);
      renderTasksList();
    }

    // ============================================
    // Links Panel
    // ============================================

    function renderLinks() {
      if (!currentRecordId) {
        linksPanel.classList.add('empty');
        return;
      }

      const record = Registry.get(currentRecordId);
      if (!record) {
        linksPanel.classList.add('empty');
        return;
      }

      const outgoing = (record.links || []).map(id => Registry.get(id)).filter(Boolean);
      const incoming = Registry.linkedTo(currentRecordId);

      if (outgoing.length === 0 && incoming.length === 0) {
        linksPanel.classList.add('empty');
        return;
      }

      linksPanel.classList.remove('empty');

      if (outgoing.length > 0) {
        outgoingSection.style.display = 'block';
        outgoingList.innerHTML = outgoing.map(r => renderLinkChip(r)).join('');
      } else {
        outgoingSection.style.display = 'none';
      }

      if (incoming.length > 0) {
        incomingSection.style.display = 'block';
        incomingList.innerHTML = incoming.map(r => renderLinkChip(r)).join('');
      } else {
        incomingSection.style.display = 'none';
      }
    }

    function renderLinkChip(record) {
      const state = getStateFromURL(record.url);
      const title = state?.t || state?.title || record.meta?.title || 'Untitled';
      const icon = record.type === 'note' ? 'üìù' :
                   record.type === 'task' ? '‚òëÔ∏è' :
                   record.type === 'template' ? 'üìÑ' :
                   record.type === 'event' ? 'üìÖ' :
                   record.type === 'project' ? 'üìÅ' : 'üìé';

      return `
        <span class="link-chip" data-link-id="${record.id}" data-type="${record.type}" data-source-app="${record.meta?.sourceApp || ''}">
          <span>${icon}</span>
          ${escapeHtml(title)}
        </span>
      `;
    }

    function navigateToLink(id, type) {
      const record = Registry.get(id);
      if (!record) return;

      if (type === 'template') {
        // Templates spawn new records in their source app
        const sourceApp = record.meta?.sourceApp || 'note';
        if (sourceApp === 'task') {
          useTemplate(id);
        } else {
          // Navigate to notes app which will spawn the note
          const hash = record.url.split('#')[1];
          window.location.href = '../note/?spawn=' + id;
        }
      } else if (type === 'task') {
        selectTask(id);
      } else if (type === 'note') {
        const hash = record.url.split('#')[1];
        window.location.href = '../note/' + (hash ? '#' + hash : '');
      } else if (type === 'event') {
        const hash = record.url.split('#')[1];
        window.location.href = '../calendar/' + (hash ? '#' + hash : '');
      }
    }

    // ============================================
    // Rendering
    // ============================================

    function renderTasksList() {
      const tasks = Registry.byType('task');
      const templates = Registry.byType('template').filter(t => t.meta?.sourceApp === 'task');
      const pending = tasks.filter(t => !t.meta?.done);
      const done = tasks.filter(t => t.meta?.done);

      let html = '';

      // Task templates
      if (templates.length > 0) {
        html += '<div class="section-label">TEMPLATES</div>';
        html += templates.map(t => {
          const state = getStateFromURL(t.url);
          const title = state?.t || t.meta?.title || 'Untitled';
          return `
            <div class="task-item template-item" data-template="${t.id}">
              <div class="task-item-content">
                <div class="task-item-title">üìÑ ${escapeHtml(title)}</div>
              </div>
              <button class="task-item-delete" data-delete-template="${t.id}">√ó</button>
            </div>
          `;
        }).join('');
      }

      if (pending.length > 0) {
        html += '<div class="section-label">TO DO</div>';
        html += pending.map(task => renderTaskItem(task)).join('');
      }

      if (done.length > 0) {
        html += '<div class="section-label">COMPLETED</div>';
        html += done.map(task => renderTaskItem(task)).join('');
      }

      if (tasks.length === 0 && templates.length === 0) {
        html = '<div class="empty-state">No tasks yet.<br>Click + to create one.</div>';
      }

      tasksListEl.innerHTML = html;
    }

    function renderTaskItem(task) {
      const state = getStateFromURL(task.url);
      const title = state?.t || task.meta?.title || 'Untitled';
      const preview = state?.b?.slice(0, 40) || '';
      const isActive = task.id === currentRecordId;
      const isDone = task.meta?.done;
      const hasLinks = (task.links?.length > 0) || Registry.linkedTo(task.id).length > 0;

      return `
        <div class="task-item ${isActive ? 'active' : ''} ${isDone ? 'completed' : ''}" data-id="${task.id}">
          <div class="task-checkbox" data-action="toggle" data-id="${task.id}"></div>
          <div class="task-item-content">
            <div class="task-item-title">${hasLinks ? 'üîó ' : ''}${escapeHtml(title)}</div>
            ${preview ? `<div class="task-item-preview">${escapeHtml(preview)}</div>` : ''}
          </div>
          <button class="task-item-delete" data-delete="${task.id}">√ó</button>
        </div>
      `;
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // ============================================
    // @ Linker Setup
    // ============================================

    let linkerState = null;

    function updateLinkerContext() {
      if (linkerState) {
        linkerState.options.recordId = currentRecordId;
        linkerState.options.excludeId = currentRecordId;
      }
    }

    // ============================================
    // Actions
    // ============================================

    function copyLink() {
      navigator.clipboard.writeText(window.location.href)
        .then(() => showStatus('Link copied!'))
        .catch(() => showStatus('Failed to copy'));
    }

    function shareTask() {
      if (navigator.share) {
        navigator.share({ title: titleEl.value || 'Task', url: window.location.href }).catch(() => {});
      } else {
        copyLink();
      }
    }

    function showStatus(message) {
      statusEl.textContent = message;
      statusEl.classList.add('visible');
      setTimeout(() => statusEl.classList.remove('visible'), 1500);
    }

    function openSidebar() { sidebarEl.classList.add('open'); backdropEl.classList.add('visible'); }
    function closeSidebar() { sidebarEl.classList.remove('open'); backdropEl.classList.remove('visible'); }

    function debounce(fn, delay) {
      let timeout;
      return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => fn(...args), delay); };
    }

    // ============================================
    // Event Listeners
    // ============================================

    const debouncedUpdate = debounce(updateCurrentTask, 300);
    titleEl.addEventListener('input', debouncedUpdate);
    bodyEl.addEventListener('input', debouncedUpdate);

    document.getElementById('new-btn').addEventListener('click', createTask);
    document.getElementById('copy-btn').addEventListener('click', copyLink);
    document.getElementById('share-btn').addEventListener('click', shareTask);
    document.getElementById('complete-btn').addEventListener('click', toggleComplete);
    document.getElementById('template-btn').addEventListener('click', saveAsTemplate);
    document.getElementById('menu-btn').addEventListener('click', openSidebar);
    backdropEl.addEventListener('click', closeSidebar);

    tasksListEl.addEventListener('click', (e) => {
      // Delete template
      const delT = e.target.closest('[data-delete-template]');
      if (delT) return deleteTemplate(delT.dataset.deleteTemplate, e);

      // Use template
      const tpl = e.target.closest('[data-template]');
      if (tpl) return useTemplate(tpl.dataset.template);

      // Toggle checkbox
      const checkbox = e.target.closest('[data-action="toggle"]');
      if (checkbox) {
        e.stopPropagation();
        const id = checkbox.dataset.id;
        // Quick toggle from list
        const record = Registry.get(id);
        if (record) {
          const state = getStateFromURL(record.url);
          const newDone = !record.meta?.done;
          const ts = record.meta?.ts || state?.ts || Date.now();
          const newState = { t: state?.t || '', b: state?.b || '', done: newDone, ts };
          const url = window.location.pathname + '#' + encodeState(newState);
          Registry.update(id, { url, meta: { ...record.meta, done: newDone, ts } });
          renderTasksList();
          if (id === currentRecordId) {
            updateCompleteButton(newDone);
          }
        }
        return;
      }

      // Delete
      const del = e.target.closest('[data-delete]');
      if (del) return deleteTask(del.dataset.delete, e);

      // Select task
      const item = e.target.closest('[data-id]');
      if (item) return selectTask(item.dataset.id);
    });

    // Link chip clicks
    linksPanel.addEventListener('click', (e) => {
      const chip = e.target.closest('.link-chip');
      if (chip) {
        navigateToLink(chip.dataset.linkId, chip.dataset.type);
      }
    });

    Registry.subscribe(() => renderTasksList());

    window.addEventListener('popstate', () => {
      const hash = window.location.hash.slice(1);
      if (hash) {
        const state = decodeState(hash);
        if (state) {
          titleEl.value = state.t || '';
          bodyEl.value = state.b || '';
          updateCompleteButton(state.done || false);
        }
      }
    });

    // ============================================
    // Init
    // ============================================

    function init() {
      // Init omnibar (nvalt-style search/create)
      Omnibar.init({
        app: 'tasks',
        onCreate: (title) => createTask(title),
        onSelect: (record) => {
          if (record.type === 'task') {
            selectTask(record.id);
            return true;
          }
          return false;
        }
      });

      // Init linker
      Linker.init();
      linkerState = Linker.attach(bodyEl, {
        recordId: null,
        excludeId: null
      });

      // Check for spawn parameter (from cross-app template link)
      const urlParams = new URLSearchParams(window.location.search);
      const spawnId = urlParams.get('spawn');
      if (spawnId) {
        // Clear the URL parameter
        history.replaceState(null, '', window.location.pathname);
        useTemplate(spawnId);
        return;
      }

      const tasks = Registry.byType('task');
      const hash = window.location.hash.slice(1);

      if (hash) {
        const state = decodeState(hash);
        if (state) {
          // Try to find existing record by timestamp first, then by URL
          let existing = null;
          if (state.ts) {
            existing = tasks.find(t => t.meta?.ts === state.ts);
          }
          if (!existing) {
            // Fallback: match by URL for old tasks without timestamp
            existing = tasks.find(t => t.url === window.location.pathname + '#' + hash);
          }

          if (existing) {
            currentRecordId = existing.id;
            // If existing task doesn't have timestamp, add one now
            if (!existing.meta?.ts) {
              const ts = Date.now();
              const newState = { ...state, ts };
              const url = window.location.pathname + '#' + encodeState(newState);
              Registry.update(existing.id, { url, meta: { ...existing.meta, ts } });
              history.replaceState(null, '', url);
            }
          } else {
            // Create new record with timestamp
            const ts = state.ts || Date.now();
            const newState = { ...state, ts };
            const url = window.location.pathname + '#' + encodeState(newState);
            const record = Registry.add('task', url, {
              meta: { title: state.t || 'Untitled', preview: state.b?.slice(0, 100), done: state.done || false, ts }
            });
            currentRecordId = record.id;
            history.replaceState(null, '', url);
          }
          titleEl.value = state.t || '';
          bodyEl.value = state.b || '';
          updateCompleteButton(state.done || false);
        }
      } else if (tasks.length > 0) {
        selectTask(tasks[0].id);
        return;
      } else {
        createTask();
        return;
      }

      updateLinkerContext();
      renderTasksList();
      renderLinks();
    }

    init();
  </script>
</body>
</html>
